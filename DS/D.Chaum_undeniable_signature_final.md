# Chaum의 부인방지 서명 (최종 수정본)

데이비드 차움(David Chaum)이 제안한 디지털 서명 방식으로, 서명자의 능동적인 참여가 있어야만 서명을 검증할 수 있는 것이 특징입니다. 이를 통해 서명자는 자신의 서명이 언제, 누구에 의해 검증되는지 완벽하게 통제할 수 있어 프라이버시 보호에 강점이 있습니다.

알고리즘은 주로 이산 로그 문제의 어려움에 기반합니다.

---

## 알고리즘 구성 요소 (파라미터 및 키)

1.  **공개 파라미터**: 모두에게 공개되는 값들입니다.
    *   `p`: 매우 큰 소수.
    *   `g`: `Z_p^*` 그룹 내에서 위수(order)가 `q`인 생성원(generator). 즉, `g^q ≡ 1 (mod p)`를 만족합니다.

2.  **키**:
    *   **개인키 `x`**: 서명자가 `2`과 `p-2` 사이에서 무작위로 선택한 정수.
    *   **공개키 `y`**: `y ≡ g^x (mod p)`를 계산한 값.

---

## 서명 과정 (Signing)

서명자가 메시지 `m`에 대해 서명 `s`를 생성하는 과정은 간단합니다.

*   `s ≡ m^x (mod p)`

결과적으로 `(m, s)` 쌍이 '서명된 메시지'가 됩니다.

---

## 확인 과정 (Verification)

검증자가 서명 `s`가 유효한지 확인하는 상호작용 과정입니다. 아래 프로토콜은 서명자가 검증자의 파라미터(`a,b`)를 미리 알 수 없도록 하여 안정성을 높인 방식입니다.

1.  **검증자 (도전)**:
    *   임의의 정수 `a, b` (`1`과 `q` 사이)를 선택합니다.
    *   도전 값 `t ≡ m^a * g^b (mod p)`를 계산하여 `t`를 서명자에게 전송합니다.

2.  **서명자 (응답)**:
    *   검증자로부터 `t`를 수신합니다.
    *   임의의 비밀값 `k`를 `2`에서 `p-1`사이에서 무작위로 선택합니다. (문서의 `q`를 `k`로 표기)
    *   `d1 ≡ t * g^k (mod p)`
    *   `d2 ≡ (d1)^x (mod p)`
    *   계산된 `(d1, d2)`를 검증자에게 전송합니다.

3.  **검증자 (파라미터 공개)**:
    *   서명자로부터 `(d1, d2)`를 수신합니다.
    *   자신이 처음에 선택했던 `a`와 `b`를 서명자에게 전송합니다.

4.  **서명자 (무결성 확인 및 비밀값 공개)**:
    *   `a, b`를 수신하고, `t' ≡ m^a * g^b (mod p)` 를 계산하여 자신이 처음에 받은 `t`와 같은지 확인합니다.
    *   일치한다면, 자신이 선택했던 비밀값 `k`를 검증자에게 전송합니다.

5.  **검증자 (최종 검증)**:
    *   비밀값 `k`를 수신합니다.
    *   자신이 받은 `d1`과 `d2`가 유효한지 아래의 `d1'`, `d2'`를 직접 계산하여 비교합니다.
    *   `d1' ≡ t * g^k (mod p)`
    *   `d2' ≡ s^a * y^(b+k) (mod p)`
    *   만약 `d1 == d1'` 이고 `d2 == d2'` 이면, 서명은 유효한 것으로 최종 확인됩니다.

---

## 부인 과정 (Disavowal Protocol)

서명자가 **위조된 서명 `s'`**이 자신의 것이 아님을 증명하는 과정입니다.

*   **사전 조건**: 위조된 서명 `s'`과, 전수 조사를 위한 작은 정수 `Z`는 서명자와 검증자 모두 미리 알고 있습니다.

1.  **검증자**:
    *   `a`를 `2`에서 `p-1`사이에서 무작위로 선택합니다.
    *   `k`를 `2`에서 `Z-1`사이에서 무작위로 선택합니다.
    *   `t1 ≡ m^k * g^a (mod p)`
    *   `t2 ≡ (s')^k * y^a (mod p)`
    *   계산된 `(t1, t2)`를 서명자에게 전송합니다.

2.  **서명자**:
    *   검증자로부터 `(t1, t2)`를 수신합니다.
    *   `(t1^x / t2) = (s/s')^k` 가 성립하는 정수 `k`를 `2`에서 `Z-1`사이에서 구합니다.

    > **[주석]** 이 단계는 서명자가 `k` 값을 `2`부터 `Z-1`까지 모두 대입해보는 **전수 조사(Brute-force search)**를 통해 `k`를 찾도록 요구합니다. `s' ≠ s` 일 경우에만 `k`가 유일하게 결정되므로 `k`를 찾을 수 있습니다. `Z`가 충분히 작아야만 현실적으로 수행 가능한 매우 특이한 방식입니다.

    *   `k`를 찾았다면, 또 다른 임의의 비밀값 `k2` 를 `2`에서 `p-1`사이에서 무작위로 선택합니다. (문서의 `q`를 `k2`로 표기)
    *   `Q ≡ g^(k*k2) (mod p)`를 구하고 `Q`를 검증자에게 전송합니다.

3.  **검증자**:
    *   서명자로부터 `Q`를 수신합니다.
    *   자신이 처음에 선택했던 `a`를 서명자에게 전송합니다.

4.  **서명자**:
    *   `a`를 수신하고, `t1' ≡ m^k * g^a (mod p)` 와 `t2' ≡ (s')^k * y^a (mod p)` 를 계산하여 `(t1,t2)`와 `(t1',t2')`가 일치하는지 확인합니다.
    *   일치한다면, 비밀값 `k2`를 검증자에게 전송합니다.

5.  **검증자**:
    *   비밀값 `k2`를 수신합니다.
    *   `Q' ≡ (g^k)^(k2) (mod p)` 를 계산하고 `Q`와 `Q'`이 일치하는지 확인합니다.
    *   **결론**: `Q`와 `Q'`이 일치하면, 서명자가 `k`를 성공적으로 찾았다는 의미이므로 `s'`은 **위조된 서명**입니다. 만약 서명자가 프로토콜을 완료하지 못해 `Q`와 `Q'`이 일치하지 않으면, `s'`은 **위조된 서명이 아닙니다.**
