# 왜 Schnorr 프로토콜은 사용자가 먼저 데이터를 보낼까? (약속 단계의 중요성)

'서버가 먼저 데이터를 보내는' 일반적인 인증 과정 설명과 달리, Schnorr나 Okamoto 같은 영지식 증명 프로토콜은 '사용자(증명자)'가 먼저 특정 값을 계산하여 서버(검증자)에게 보내는 것으로 시작합니다.

이 단계는 프로토콜의 보안성을 지키기 위한 핵심적인 장치이며, **약속(Commitment)** 단계라고 부릅니다.

## 만약 "약속" 단계가 없다면?

만약 Schnorr 프로토콜이 서버(검증자)가 먼저 임의의 데이터 `e`를 보내는 것으로 시작한다고 가정해 보겠습니다. 이 경우, **개인키를 모르는 공격자(가짜 사용자)가 인증을 통과할 수 있게 됩니다.**

### 취약한 가상 프로토콜의 예시

1.  **서버 → 공격자 (질문):** 서버가 먼저 임의의 `e`를 보냅니다.
2.  **공격자의 계산 (조작):** 공격자는 개인키 `x`를 모릅니다. 하지만 최종 검증식인 `g^s == r * y^e`를 통과하는 것이 목표입니다.
    *   공격자는 이 식을 만족시키기 위해 **역으로 계산을 시작**합니다.
    *   먼저 `s` 값을 아무거나 임의로 정합니다.
    *   그런 다음, `r` 값을 `r = g^s * (y^e)^-1` (즉, `g^s / y^e`) 로 계산해서 만들어 냅니다.
3.  **공격자 → 서버 (응답):** 이렇게 조작해서 만든 `(r, s)` 쌍을 서버에 보냅니다.
4.  **서버의 검증:** 서버는 `g^s == r * y^e` 인지 확인합니다. 공격자는 이 식이 성립하도록 `r`값을 만들었기 때문에, **검증은 성공**하게 됩니다.

결과적으로, 개인키를 전혀 모르는 공격자가 진짜 사용자인 것처럼 행세하는 데 성공하고 맙니다.

---

## "약속" 단계가 이 문제를 해결하는 방법

이제 원래의 올바른 Schnorr 프로토콜의 흐름을 다시 살펴보겠습니다.

1.  **사용자 → 서버 (약속 단계):** 사용자는 먼저 임의의 `k`를 정하고, `r = g^k`를 계산해서 서버에 보냅니다.
    *   이것은 마치 "나는 지금부터 `k`라는 숫자를 마음속에 정했고, 절대 바꾸지 않을 것임을 `r`을 통해 약속합니다" 라고 선언하는 것과 같습니다. 사용자는 이 약속을 번복할 수 없습니다.

2.  **서버 → 사용자 (질문 단계):** 서버는 `r`을 받은 뒤, 예측할 수 없는 임의의 `e`를 사용자에게 보냅니다.

3.  **사용자 → 서버 (응답 단계):** 사용자는 이제 **이미 약속한 `k`**와 서버가 보내준 `e`, 그리고 **자신만이 아는 개인키 `x`**를 조합하여 `s = k + e*x` 를 계산합니다.
    *   `k`값이 맨 처음에 고정되었기 때문에, 사용자는 더 이상 `s`나 `r`값을 조작하여 역산을 할 수 없습니다. 올바른 `s`를 계산하기 위해서는 반드시 개인키 `x`를 알고 있어야만 합니다.

---

## 요약

| 구분 | 일반적인 설명 (단순화된 개념) | Schnorr 프로토콜 (엄밀한 구현) |
| :--- | :--- | :--- |
| **시작** | 서버가 사용자에게 '도전(Challenge)' 데이터를 보냄 | 사용자가 서버에게 '약속(Commitment)' 데이터를 먼저 보냄 |
| **목적** | 사용자가 진짜인지 확인 | 사용자가 **정직하게** 진짜임을 증명하는지 확인 |
| **차이의 이유**| 개념적 이해를 돕기 위함 | 사용자의 **부정행위(위조, 역산)를 원천적으로 차단**하기 위함 |

결론적으로, Schnorr 프로토콜에서 사용자가 먼저 값을 보내는 행위는 인증 과정을 안전하게 만들기 위한 필수적인 **"약속(Commitment)"** 단계입니다.
