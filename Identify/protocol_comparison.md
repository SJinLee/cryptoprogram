# Schnorr & Okamoto 개인 식별 프로토콜 비교

두 방식 모두 증명자(Prover)가 검증자(Verifier)에게 **비밀키를 노출하지 않고 비밀키를 알고 있음을 증명**하는 3단계(3-Pass) 상호작용 프로토콜입니다.

---

### Schnorr 개인 식별 프로토콜

**기반:** 이산 로그 문제 (생성자 1개, 비밀키 1개)

#### 1. 사전 준비 (Setup)
*   **증명자:**
    *   개인키: `x`
    *   공개키: `y = g^x mod p` (검증자에게 미리 등록)

#### 2. 프로토콜 실행 (증명 과정)

| 단계 | 주체 | 수행 내용 |
| :--- | :--- | :--- |
| **1. 약속 (Commitment)** | **증명자** → 검증자 | 1. 임의의 수 `k`를 선택합니다.<br>2. `r = g^k mod p`를 계산하여 `r`을 보냅니다. |
| **2. 질문 (Challenge)** | 증명자 ← **검증자** | 1. 임의의 수 `e`를 선택합니다.<br>2. `e`를 보냅니다. |
| **3. 응답 (Response)** | **증명자** → 검증자 | 1. `s = k + e * x mod q`를 계산합니다.<br>2. `s`를 보냅니다. |

#### 3. 검증 (Verification)
*   **검증자:** `g^s` 와 `r * y^e` 값이 같은지 확인합니다. (`g^s == r * y^e mod p`)
*   같으면 증명 성공.

---

### Okamoto 개인 식별 프로토콜

**기반:** 이산 로그 문제 (생성자 2개, 비밀키 2개)

#### 1. 사전 준비 (Setup)
*   **증명자:**
    *   개인키: `(s1, s2)`
    *   공개키: `v = (g1^s1 * g2^s2) mod p` (검증자에게 미리 등록)

#### 2. 프로토콜 실행 (증명 과정)

| 단계 | 주체 | 수행 내용 |
| :--- | :--- | :--- |
| **1. 약속 (Commitment)** | **증명자** → 검증자 | 1. 임의의 수 쌍 `(r1, r2)`를 선택합니다.<br>2. `x = (g1^r1 * g2^r2) mod p`를 계산하여 `x`를 보냅니다. |
| **2. 질문 (Challenge)** | 증명자 ← **검증자** | 1. 임의의 수 `c`를 선택합니다.<br>2. `c`를 보냅니다. |
| **3. 응답 (Response)** | **증명자** → 검증자 | 1. `y1 = r1 + c * s1 mod q`<br>2. `y2 = r2 + c * s2 mod q`<br>3. `(y1, y2)` 쌍을 보냅니다. |

#### 3. 검증 (Verification)
*   **검증자:** `g1^y1 * g2^y2` 와 `x * v^c` 값이 같은지 확인합니다. (`g1^y1 * g2^y2 == x * v^c mod p`)
*   같으면 증명 성공.

---

### 핵심 차이점 요약

| 구분 | Schnorr 프로토콜 | Okamoto 프로토콜 |
| :--- | :--- | :--- |
| **비밀키** | 1개 (`x`) | 2개 (`s1`, `s2`) |
| **생성자** | 1개 (`g`) | 2개 (`g1`, `g2`) |
| **약속(Commitment)** | `r = g^k` (값 1개) | `x = g1^r1 * g2^r2` (값 1개) |
| **응답(Response)** | `s = k + e*x` (값 1개) | `(y1, y2)` (값 2개) |
| **검증식** | `g^s = r * y^e` | `g1^y1 * g2^y2 = x * v^c` |
