{% extends 'base.html' %}
{% block content %}
    <h1>Merkle-Hellman Knapsack 암호화/복호화 방법</h1>
    
    <h2>개요</h2>
    <p>Merkle-Hellman Knapsack 암호 시스템은 초증가 수열(superincreasing sequence)을 기반으로 합니다. 이 수열은 각 항이 그 이전의 모든 항의 합보다 크다는 특징을 가집니다. (예: {1, 2, 4, 8, 16})</p>

    <h2>키 생성</h2>
    <ol>
        <li><b>개인키 (Private Key) 생성:</b>
            <ul>
                <li>초증가 수열 𝑤 = (𝑤₁, 𝑤₂, ..., 𝑤ₙ)를 선택합니다. 이것이 개인키의 일부입니다.</li>
                <li>𝑤의 모든 항의 합보다 큰 소수 𝑝를 선택합니다.</li>
                <li>𝑝와 서로소인 정수 𝑦를 선택합니다. (1 < y < p)</li>
                <li>개인키는 (𝑤, 𝑝, 𝑦) 입니다.</li>
            </ul>
        </li>
        <li><b>공개키 (Public Key) 생성:</b>
            <ul>
                <li>공개키 수열 β = (β₁, β₂, ..., βₙ)를 계산합니다. 각 항은 βᵢ = (𝑤ᵢ * 𝑦) mod 𝑝 입니다.</li>
                <li>공개키는 β 입니다.</li>
            </ul>
        </li>
    </ol>

    <h2>암호화 (Encryption)</h2>
    <p>평문 메시지를 이진 벡터 α = (α₁, α₂, ..., αₙ)로 변환합니다. (예: 'A' -> 01000001)</p>
    <p>암호문 C는 공개키 β와 평문 벡터 α의 내적(dot product)으로 계산됩니다.</p>
    <p>C = Σ (αᵢ * βᵢ) for i=1 to n</p>

    <h2>복호화 (Decryption)</h2>
    <ol>
        <li>먼저, 𝑦의 모듈러 곱셈 역원 𝑦⁻¹를 계산합니다. (𝑦 * 𝑦⁻¹ ≡ 1 mod 𝑝)</li>
        <li>암호문 C에 𝑦⁻¹를 곱하고 모듈러 𝑝 연산을 수행하여 C'를 얻습니다.</li>
        <p>C' = (C * 𝑦⁻¹) mod 𝑝</p>
        <li>C'는 원래의 초증가 수열 𝑤와 평문 벡터 α의 내적과 같습니다. (C' = Σ αᵢ * 𝑤ᵢ)</li>
        <li>초증가 수열의 특성을 이용하여 C'로부터 평문 벡터 α를 쉽게 복원할 수 있습니다. (가장 큰 𝑤ᵢ부터 C'와 비교하여 뺄셈)</li>
    </ol>

{% endblock %}
